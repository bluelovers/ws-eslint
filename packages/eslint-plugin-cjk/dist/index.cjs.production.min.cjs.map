{"version":3,"file":"index.cjs.production.min.cjs","sources":["../src/rules/utils/ast-utils.ts","../src/rules/utils/helper.ts","../src/utils/re.ts","../src/rules/no-irregular-whitespace.ts","../src/rules/index.ts","../src/const.ts","../src/index.ts"],"sourcesContent":["/*\n * https://github.com/eslint/eslint/blob/main/lib/shared/ast-utils.js\n */\n\nexport const lineBreakPattern = /\\r\\n|[\\r\\n\\u2028\\u2029]/u;\n\n/**\n * Creates a version of the `lineBreakPattern` regex with the global flag.\n * Global regexes are mutable, so this needs to be a function instead of a constant.\n * @returns {RegExp} A global regular expression that matches line terminators\n */\nexport function createGlobalLinebreakMatcher()\n{\n\treturn new RegExp(lineBreakPattern.source, \"gu\");\n}\n","import { Rule } from 'eslint';\nimport { ESLINT_SWITCH } from '../../const';\n\ntype _IOptions = ESLINT_SWITCH | [ESLINT_SWITCH, ...any[]];\n\nexport function createRule<META extends Readonly<Record<string, any>>, RULE extends Rule.RuleModule, NAME extends string, EXTRA extends Record<string, any>>(meta: META & {\n\treadonly name: NAME,\n\treadonly configs?: {\n\t\t[name: string]: _IOptions,\n\t\trecommended: _IOptions,\n\n\t}\n} & EXTRA, rule: RULE)\n{\n\treturn {\n\t\t...meta,\n\t\trule,\n\t}\n}\n","/**\n * remove regexp in ignores\n * @private\n */\nexport function removeRegexClass(re: RegExp, ignoresRe: RegExp): RegExp\n{\n\tif (!ignoresRe)\n\t{\n\t\treturn re;\n\t}\n\n\tconst source = re.source.replace(ignoresRe, \"\");\n\n\treturn new RegExp(source, re.flags);\n}\n\nexport function handleIgnoreRe(ignores: string[]): RegExp\n{\n\tif (!ignores || !ignores?.length)\n\t{\n\t\treturn null;\n\t}\n\n\tconst source = ignores\n\t\t.map(c =>\n\t\t{\n\t\t\tif (c === \"\\f\" || c === \"\\\\f\" || c === \"\\\\\\\\f\")\n\t\t\t{\n\t\t\t\treturn \"\\\\\\\\f\";\n\t\t\t}\n\t\t\telse if (c === \"\\v\" || c === \"\\\\v\" || c === \"\\\\\\\\v\")\n\t\t\t{\n\t\t\t\treturn \"\\\\\\\\v\";\n\t\t\t}\n\t\t\telse if (c.startsWith(\"\\\\\\\\u\"))\n\t\t\t{\n\t\t\t\treturn c;\n\t\t\t}\n\t\t\telse if (c.length === 1)\n\t\t\t{\n\t\t\t\treturn `\\\\\\\\u${c.codePointAt(0).toString(16)}`;\n\t\t\t}\n\t\t\telse if (c.startsWith(\"\\\\\\\\\"))\n\t\t\t{\n\t\t\t\treturn c;\n\t\t\t}\n\n\t\t\tthrow new TypeError(`${c} \\\\u${c.codePointAt(0).toString(16)}`);\n\t\t})\n\t\t.join(\"|\")\n\t;\n\n\treturn new RegExp(source, \"ug\");\n}\n","/**\n *\n * @fileoverview Rule to disallow whitespace that is not a tab or space, whitespace inside strings and comments are allowed\n * @author Jonathan Kingston\n * @author Christophe Porteneuve\n *\n * @see https://github.com/eslint/eslint/blob/main/lib/rules/no-irregular-whitespace.js\n */\n\n\"use strict\";\n\n//------------------------------------------------------------------------------\n// Requirements\n//------------------------------------------------------------------------------\n\nimport { createGlobalLinebreakMatcher } from './utils/ast-utils';\nimport { createRule } from './utils/helper';\nimport { handleIgnoreRe, removeRegexClass } from '../utils/re';\nimport { ESLINT_META_TYPE, ESLINT_SWITCH } from '../const';\n\n//------------------------------------------------------------------------------\n// Constants\n//------------------------------------------------------------------------------\n\n/**\n * @deprecated\n * @type {RegExp}\n */\nconst ALL_IRREGULARS = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000\\u2028\\u2029]/u;\n/**\n * @deprecated\n * @type {RegExp}\n */\nconst IRREGULAR_WHITESPACE = /[\\f\\v\\u0085\\ufeff\\u00a0\\u1680\\u180e\\u2000\\u2001\\u2002\\u2003\\u2004\\u2005\\u2006\\u2007\\u2008\\u2009\\u200a\\u200b\\u202f\\u205f\\u3000]+/mgu;\nconst IRREGULAR_LINE_TERMINATORS = /[\\u2028\\u2029]/mgu;\nconst LINE_BREAK = createGlobalLinebreakMatcher();\n\n//------------------------------------------------------------------------------\n// Rule Definition\n//------------------------------------------------------------------------------\n\nconst ERROR_MESSAGE = \"Irregular whitespace not allowed.\";\n\nexport interface IOptions\n{\n\tskipComments?: boolean,\n\tskipStrings?: boolean,\n\tskipRegExps?: boolean,\n\tskipTemplates?: boolean,\n\tignores?: string[],\n}\n\nconst MESSAGE_ID = \"noIrregularWhitespace\" as const;\n\nexport const noIrregularWhitespace = createRule({\n\tname: \"no-irregular-whitespace-extra\",\n\n\tconfigs: {\n\t\trecommended: [\n\t\t\tESLINT_SWITCH.ERROR, <IOptions>{\n\t\t\t\t\"skipComments\": true,\n\t\t\t\t\"skipStrings\": false,\n\t\t\t\t\"skipTemplates\": false,\n\t\t\t\t\"skipRegExps\": false,\n\t\t\t\t\"ignores\": ['\\u3000'],\n\t\t\t},\n\t\t],\n\t},\n\n\tmessageId: MESSAGE_ID,\n\n}, {\n\n\tmeta: {\n\t\ttype: ESLINT_META_TYPE.PROBLEM,\n\n\t\tdocs: {\n\t\t\tdescription: \"disallow irregular whitespace\",\n\t\t\tcategory: \"Possible Errors\",\n\t\t\trecommended: true,\n\t\t\turl: \"https://eslint.org/docs/rules/no-irregular-whitespace\",\n\t\t},\n\n\t\tschema: [\n\t\t\t{\n\t\t\t\ttype: \"object\",\n\t\t\t\tproperties: {\n\t\t\t\t\tskipComments: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t},\n\t\t\t\t\tskipStrings: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: true,\n\t\t\t\t\t},\n\t\t\t\t\tskipTemplates: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t},\n\t\t\t\t\tskipRegExps: {\n\t\t\t\t\t\ttype: \"boolean\",\n\t\t\t\t\t\tdefault: false,\n\t\t\t\t\t},\n\t\t\t\t\tignores: {\n\t\t\t\t\t\ttype: \"array\",\n\t\t\t\t\t\titems: {\n\t\t\t\t\t\t\ttype: \"string\",\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t},\n\t\t\t\tadditionalProperties: false,\n\t\t\t},\n\t\t],\n\n\t\tmessages: {\n\t\t\t[MESSAGE_ID]: ERROR_MESSAGE,\n\t\t},\n\t},\n\n\tdefaultOptions: [\n\t\tESLINT_SWITCH.ERROR, <IOptions>{\n\t\t\t\"skipComments\": true,\n\t\t\t\"skipStrings\": false,\n\t\t\t\"skipTemplates\": false,\n\t\t\t\"skipRegExps\": false,\n\t\t\tignores: [],\n\t\t},\n\t],\n\n\tcreate(context)\n\t{\n\n\t\t// Module store of errors that we have found\n\t\tlet errors: any[] = [];\n\n\t\t// Lookup the `skipComments` option, which defaults to `false`.\n\t\tconst options = context.options[0] || {};\n\t\tconst skipComments = !!options.skipComments;\n\t\tconst skipStrings = options.skipStrings !== false;\n\t\tconst skipRegExps = !!options.skipRegExps;\n\t\tconst skipTemplates = !!options.skipTemplates;\n\n\t\tconst sourceCode = context.getSourceCode();\n\t\tconst commentNodes = sourceCode.getAllComments();\n\n\t\tconst ignoresRe: RegExp = handleIgnoreRe(options.ignores);\n\n\t\tconst ALL_IRREGULARS_LOCAL = removeRegexClass(ALL_IRREGULARS, ignoresRe);\n\t\tconst IRREGULAR_WHITESPACE_LOCAL = removeRegexClass(IRREGULAR_WHITESPACE, ignoresRe);\n\n\t\t/**\n\t\t * Removes errors that occur inside the given node\n\t\t * @param {ASTNode} node to check for matching errors.\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\tfunction removeWhitespaceError(node: any)\n\t\t{\n\t\t\tconst locStart = node.loc.start;\n\t\t\tconst locEnd = node.loc.end;\n\n\t\t\terrors = errors.filter(({ loc: { start: errorLocStart } }) => (\n\t\t\t\terrorLocStart.line < locStart.line ||\n\t\t\t\terrorLocStart.line === locStart.line && errorLocStart.column < locStart.column ||\n\t\t\t\terrorLocStart.line === locEnd.line && errorLocStart.column >= locEnd.column ||\n\t\t\t\terrorLocStart.line > locEnd.line\n\t\t\t));\n\t\t}\n\n\t\t/**\n\t\t * Checks identifier or literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n\t\t * @param {ASTNode} node to check for matching errors.\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\tfunction removeInvalidNodeErrorsInIdentifierOrLiteral(node: any)\n\t\t{\n\t\t\tconst shouldCheckStrings = skipStrings && (typeof node.value === \"string\");\n\t\t\tconst shouldCheckRegExps = skipRegExps && Boolean(node.regex);\n\n\t\t\tif (shouldCheckStrings || shouldCheckRegExps)\n\t\t\t{\n\n\t\t\t\t// If we have irregular characters remove them from the errors list\n\t\t\t\tif (ALL_IRREGULARS_LOCAL.test(node.raw))\n\t\t\t\t{\n\t\t\t\t\tremoveWhitespaceError(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Checks template string literal nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n\t\t * @param {ASTNode} node to check for matching errors.\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\tfunction removeInvalidNodeErrorsInTemplateLiteral(node: any)\n\t\t{\n\t\t\tif (typeof node.value.raw === \"string\")\n\t\t\t{\n\t\t\t\tif (ALL_IRREGULARS_LOCAL.test(node.value.raw))\n\t\t\t\t{\n\t\t\t\t\tremoveWhitespaceError(node);\n\t\t\t\t}\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Checks comment nodes for errors that we are choosing to ignore and calls the relevant methods to remove the errors\n\t\t * @param {ASTNode} node to check for matching errors.\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\tfunction removeInvalidNodeErrorsInComment(node: any)\n\t\t{\n\t\t\tif (ALL_IRREGULARS_LOCAL.test(node.value))\n\t\t\t{\n\t\t\t\tremoveWhitespaceError(node);\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * Checks the program source for irregular whitespace\n\t\t * @param {ASTNode} node The program node\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\tfunction checkForIrregularWhitespace(node: any)\n\t\t{\n\t\t\tconst sourceLines = sourceCode.lines;\n\n\t\t\tsourceLines.forEach((sourceLine, lineIndex) =>\n\t\t\t{\n\t\t\t\tconst lineNumber = lineIndex + 1;\n\t\t\t\tlet match;\n\n\t\t\t\twhile ((match = IRREGULAR_WHITESPACE_LOCAL.exec(sourceLine)) !== null)\n\t\t\t\t{\n\t\t\t\t\terrors.push({\n\t\t\t\t\t\tnode,\n\t\t\t\t\t\tmessageId: MESSAGE_ID,\n\t\t\t\t\t\tloc: {\n\t\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\t\tline: lineNumber,\n\t\t\t\t\t\t\t\tcolumn: match.index,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\t\tline: lineNumber,\n\t\t\t\t\t\t\t\tcolumn: match.index + match[0].length,\n\t\t\t\t\t\t\t},\n\t\t\t\t\t\t},\n\t\t\t\t\t});\n\t\t\t\t}\n\t\t\t});\n\t\t}\n\n\t\t/**\n\t\t * Checks the program source for irregular line terminators\n\t\t * @param {ASTNode} node The program node\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\tfunction checkForIrregularLineTerminators(node: any)\n\t\t{\n\t\t\tconst source = sourceCode.getText(),\n\t\t\t\tsourceLines = sourceCode.lines,\n\t\t\t\tlinebreaks = source.match(LINE_BREAK);\n\t\t\tlet lastLineIndex = -1,\n\t\t\t\tmatch;\n\n\t\t\twhile ((match = IRREGULAR_LINE_TERMINATORS.exec(source)) !== null)\n\t\t\t{\n\t\t\t\tconst lineIndex = linebreaks.indexOf(match[0], lastLineIndex + 1) || 0;\n\n\t\t\t\terrors.push({\n\t\t\t\t\tnode,\n\t\t\t\t\tmessageId: MESSAGE_ID,\n\t\t\t\t\tloc: {\n\t\t\t\t\t\tstart: {\n\t\t\t\t\t\t\tline: lineIndex + 1,\n\t\t\t\t\t\t\tcolumn: sourceLines[lineIndex].length,\n\t\t\t\t\t\t},\n\t\t\t\t\t\tend: {\n\t\t\t\t\t\t\tline: lineIndex + 2,\n\t\t\t\t\t\t\tcolumn: 0,\n\t\t\t\t\t\t},\n\t\t\t\t\t},\n\t\t\t\t});\n\n\t\t\t\tlastLineIndex = lineIndex;\n\t\t\t}\n\t\t}\n\n\t\t/**\n\t\t * A no-op function to act as placeholder for comment accumulation when the `skipComments` option is `false`.\n\t\t * @returns {void}\n\t\t * @private\n\t\t */\n\t\t// @formatter:off\n\t\t// eslint-disable-next-line @typescript-eslint/no-empty-function,no-empty-function\n\t\tfunction noop() {}\n\t\t// @formatter:on\n\n\t\tconst nodes: any = {};\n\n\t\tif (ALL_IRREGULARS_LOCAL.test(sourceCode.getText()))\n\t\t{\n\t\t\tnodes.Program = function (node: any)\n\t\t\t{\n\n\t\t\t\t/*\n\t\t\t\t * As we can easily fire warnings for all white space issues with\n\t\t\t\t * all the source its simpler to fire them here.\n\t\t\t\t * This means we can check all the application code without having\n\t\t\t\t * to worry about issues caused in the parser tokens.\n\t\t\t\t * When writing this code also evaluating per node was missing out\n\t\t\t\t * connecting tokens in some cases.\n\t\t\t\t * We can later filter the errors when they are found to be not an\n\t\t\t\t * issue in nodes we don't care about.\n\t\t\t\t */\n\t\t\t\tcheckForIrregularWhitespace(node);\n\t\t\t\tcheckForIrregularLineTerminators(node);\n\t\t\t};\n\n\t\t\tnodes.Identifier = removeInvalidNodeErrorsInIdentifierOrLiteral;\n\t\t\tnodes.Literal = removeInvalidNodeErrorsInIdentifierOrLiteral;\n\t\t\tnodes.TemplateElement = skipTemplates ? removeInvalidNodeErrorsInTemplateLiteral : noop;\n\t\t\tnodes[\"Program:exit\"] = function ()\n\t\t\t{\n\t\t\t\tif (skipComments)\n\t\t\t\t{\n\n\t\t\t\t\t// First strip errors occurring in comment nodes.\n\t\t\t\t\tcommentNodes.forEach(removeInvalidNodeErrorsInComment);\n\t\t\t\t}\n\n\t\t\t\t// If we have any errors remaining report on them\n\t\t\t\terrors.forEach(error => context.report(error));\n\t\t\t};\n\t\t}\n\t\telse\n\t\t{\n\t\t\tnodes.Program = noop;\n\t\t}\n\n\t\treturn nodes;\n\t},\n});\n\nexport default noIrregularWhitespace\n","\nimport { default as noIrregularWhitespace } from './no-irregular-whitespace';\n\nexport const rules = {\n\t[noIrregularWhitespace.name]: noIrregularWhitespace.rule,\n};\n\nexport default rules;\n\n","export const PLUGIN_NAME = 'cjk' as const;\n\nexport const enum ESLINT_SWITCH\n{\n\tERROR = 'error',\n\tOFF = \"off\"\n}\n\nexport const enum ESLINT_META_TYPE\n{\n\tPROBLEM = 'problem'\n}\n","import { rules } from \"./rules\";\nimport { ESLINT_SWITCH, PLUGIN_NAME } from './const';\nimport noIrregularWhitespace from './rules/no-irregular-whitespace';\n\nexport { rules }\n\nexport const configs = {\n\trecommended: {\n\t\tplugins: [PLUGIN_NAME],\n\t\trules: {\n\t\t\t\"no-irregular-whitespace\": [\n\t\t\t\tESLINT_SWITCH.OFF,\n\t\t\t\t{\n\t\t\t\t\t\"skipComments\": true,\n\t\t\t\t\t\"skipStrings\": false,\n\t\t\t\t\t\"skipTemplates\": false,\n\t\t\t\t\t\"skipRegExps\": false,\n\t\t\t\t},\n\t\t\t],\n\t\t\t[`${PLUGIN_NAME}/no-irregular-whitespace-extra` as const]: noIrregularWhitespace.configs.recommended,\n\t\t},\n\t},\n};\n"],"names":["lineBreakPattern","createGlobalLinebreakMatcher","RegExp","source","createRule","meta","rule","removeRegexClass","re","ignoresRe","replace","flags","ALL_IRREGULARS","IRREGULAR_WHITESPACE","IRREGULAR_LINE_TERMINATORS","LINE_BREAK","MESSAGE_ID","noIrregularWhitespace","name","configs","recommended","messageId","type","docs","description","category","url","schema","properties","skipComments","default","skipStrings","skipTemplates","skipRegExps","ignores","items","additionalProperties","messages","defaultOptions","create","context","errors","options","sourceCode","getSourceCode","commentNodes","getAllComments","length","map","c","startsWith","codePointAt","toString","TypeError","join","handleIgnoreRe","ALL_IRREGULARS_LOCAL","IRREGULAR_WHITESPACE_LOCAL","removeWhitespaceError","node","locStart","loc","start","locEnd","end","filter","errorLocStart","line","column","removeInvalidNodeErrorsInIdentifierOrLiteral","shouldCheckStrings","value","shouldCheckRegExps","Boolean","regex","test","raw","removeInvalidNodeErrorsInComment","noop","nodes","getText","Program","lines","forEach","sourceLine","lineIndex","lineNumber","match","exec","push","index","checkForIrregularWhitespace","sourceLines","linebreaks","lastLineIndex","indexOf","checkForIrregularLineTerminators","Identifier","Literal","TemplateElement","error","report","rules","ESLINT_SWITCH","ESLINT_META_TYPE","plugins"],"mappings":"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"}